# 浏览器

## 浏览器原生能力 在新页面触发事件 执行父页面中的方法

### 在父组建注册

```js
// open('https://xxx').opener 指向window 上面会有updateFun 方法
window.open('https://xxx').opener.updateList = (flag) => {
  console.log(flag)
}
`

```js
  window.opener.updateList('inventory-create')
```

## 浏览器缓存机制

> 浏览器缓存机制是一种优化网页加载速度的技术，通过将资源存储在本地，减少重复请求，提升用户体验。以下是其核心要点：

### 1. **缓存类型** https://juejin.cn/post/6844903593275817998#heading-3
- **强缓存**：浏览器直接从本地缓存读取资源，不发送请求到服务器。
    - 相关头字段：
        - `Expires`：指定资源的过期时间（HTTP/1.0）。
        - `Cache-Control`：更灵活的缓存控制（HTTP/1.1），常见值：
            - `max-age`：资源有效期（秒）。
            - `no-cache`：需验证资源是否过期。
            - `no-store`：禁止缓存。
            - `public`：允许所有用户缓存。
            - `private`：仅允许单个用户缓存。

- **协商缓存**：当强缓存失效时，浏览器向服务器验证资源是否更新。
    - 相关头字段：
        - `Last-Modified` / `If-Modified-Since`：基于资源修改时间。
        - `ETag` / `If-None-Match`：基于资源唯一标识。
        - HTTP1.0:请求头：if-modified-since 响应头：last-modified
        - HTTP1.1:请求头：if-none-match 响应头：Etag

### 2. **缓存流程**
1. 浏览器请求资源时，先检查强缓存。
2. 若强缓存有效，直接使用缓存资源。
3. 若强缓存失效，浏览器向服务器发送请求，验证协商缓存。
4. 若资源未更新（304状态码），继续使用缓存；若已更新（200状态码），返回新资源并更新缓存。

### 3. **缓存位置**
- **Memory Cache**：内存缓存，速度快但容量小，页面关闭后失效。
- **Disk Cache**：磁盘缓存，速度较慢但容量大，持久存储。

### 4. **缓存策略**
- **HTML文件**：通常不缓存或设置较短缓存时间，确保用户获取最新内容。
- **静态资源**（如CSS、JS、图片）：设置较长缓存时间，通过文件名哈希或版本号控制更新。

### 5. **缓存优点**
- **减少请求**：降低服务器负载。
- **加快加载**：提升用户体验。
- **节省带宽**：减少重复下载。

### 6. **缓存缺点**
- **资源更新延迟**：可能导致用户看到旧内容。
- **缓存管理复杂**：需合理设置缓存策略。

### 7. **缓存控制**
- 通过HTTP头字段（如`Cache-Control`、`Expires`）或HTML的`<meta>`标签控制缓存行为。

### 总结
浏览器缓存机制通过存储资源减少重复请求，提升性能，但需合理设置缓存策略以平衡性能和资源更新。

## V8垃圾回收机制
[V8垃圾回收机制](https://segmentfault.com/a/1190000025129635)

## 浏览器缓存机制
[缓存机制](https://www.cnblogs.com/suihang/p/12855345.html)
[浏览器缓存机制](https://www.jianshu.com/p/54cc04190252)


## 简述一下src与href的区别
href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。

src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

## cookie、localStorage、sessionStorage区别

| 特性 | cookie  | localStorage | sessionStorage |
|:--|:--|:--|:--|
| 由谁初始化 | 客户端或服务器，服务器可以使用Set-Cookie请求头。 | 客户端 |  客户端|
| 数据的生命周期 |一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效  |永久有效，可以被清除 | 关闭浏览器失效 |
| 存放数据大小 | 4KB | 5M | 5M |
| 与服务器通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题	 | 仅在客户端保存 | 仅在客户端保存 |
|  与服务器通信| 一般由服务器生成，用于标识用户身份 | 用于浏览器缓存数据 |用于浏览器缓存数据  |
|  访问权限| 任意窗口 | 任意窗口 | 当前页面窗口 |\

## 浏览器从输入URL到页面渲染的过程
https://juejin.cn/post/6984339284534755358
DNS解析
建立TCP连接
发送 HTTP / HTTPS 请求（建立 TLS 连接）
服务器响应请求
渲染页面
   - 浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树
   - 再把CSS解析成CSSOM
   - 把DOM和CSSOM合并为渲染树
   - 布局
   - 把渲染树的每个节点渲染到屏幕上（绘制）
断开TCP连接

## 从输入url到页面加载

https://vue3js.cn/interview/http/after_url.html#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90


### token存在sessionStorage还是loaclsSorage
token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串
1.存localStorage里，后期每次请求接口都需要把它当作一个字段传给后台
2.存cookie中，会自动发送，缺点就是不能跨域
如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊
如果存在cookie中会有CSRF攻击


### DOM树和渲染树有什么区别？
DOM树是和HTML标签一一对应的，包括head和隐藏元素
渲染树是不包含head和隐藏元素

### 精灵图和base64的区别是什么？
精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度
base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串
base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。

### svg格式了解多少？
基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真
1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作
<svg></svg>
2.SVG可作为文件被引入
<img src="pic.svg" />
3.SVG可以转为base64引入页面

### 了解过JWT吗？
JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
信息传输、授权
JWT的认证流程
1.前端把账号密码发送给后端的接口
2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。
3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内
4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。

### HTTP协议规定的协议头和请求头有什么？
1.请求头信息：
Accept:浏览器告诉服务器所支持的数据类型
Host:浏览器告诉服务器我想访问服务器的哪台主机
Referer:浏览器告诉服务器我是从哪里来的（防盗链）
User-Agent:浏览器类型、版本信息
Date:浏览器告诉服务器我是什么时候访问的
Connection:连接方式
Cookie
X-Request-With:请求方式
2.响应头信息：
Location:这个就是告诉浏览器你要去找谁
Server:告诉浏览器服务器的类型
Content-Type:告诉浏览器返回的数据类型
Refresh:控制了的定时刷新

## 浏览器中的、事件循环

JavaScript 的主要用途是与用户互动, 以及操作 DOM。
如果它是多线程的会有很多复杂的问题要处理, 比如有两个线程同时操作 DOM, 一个线程删除了当前的 DOM 节点, 一个线程是要操作当前的DOM, 这样就会有冲突.  为了避免这种, 所以 JS 是单线程的。
即使 H5 提出了 web worker 标准, 它有很多限制, 受主线程控制, 是主线程的子线程, 也是不允许操作DOM.

单线程就意味着所有的任务都需要排队, 后面的任务需要等前面的任务执行完才能执行, 如果前面的任务耗时过长, 后面的任务就需要一直等, 一些从用户角度上不需要等待的任务就会一直等待, 这个从体验角度上来讲是不可接受的, 所以JS中就出现了异步的概念。

JavaScript 代码的执行过程中, 除了依靠函数调用栈来搞定函数的执行顺序外, 还依靠任务队列(task queue)来搞定另外一些代码的执行。一个线程中, 事件循环是唯一的, 但是任务队列可以拥有多个。任务队列又分为 macro-task（宏任务）与 micro-task（微任务）, 在最新标准中, 它们被分别称为 task与jobs。

### 同步任务

代码从上到下按顺序执行

### 异步任务

macro-task 大概包括：

- script(整体代码)
- setTimeout
- setInterval
- setImmediate
- UI交互事件(click, doubleClick)
- postMessage
- Ajax

micro-task 大概包括:

- process.nextTick(Node.js 环境)
- Promise.then catch finally
- Async/Await(实际就是 promise)
- MutationObserver(html5 新特性)

### 运行机制

所有的同步任务都是在主进程执行的形成一个执行栈, 主线程之外, 还存在一个"任务队列[task queue]", 异步任务执行队列中先执行宏任务, 然后清空当次宏任务中的所有微任务, 然后进行下一个tick如此形成循环。

[事件循环机制](https://cloud.tencent.com/developer/article/1601176)


## 说说TCP为什么需要三次握手和四次挥手

https://vue3js.cn/interview/http/handshakes_waves.html#%E4%B8%80%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B

## 说一下什么是“同源策略”
* http:// www.  aaa.com:8080/index/vue.js
* 协议    子域名 主域名  端口号     资源
* 同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击
* 主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域
* 三个允许跨域加载资源的标签：img  link  script
* 跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了
* JSONP
* CORS
* websocket
* 反向代理

## DOM树和渲染树有什么区别
- DOM树是和HTML标签一一对应的，包括head和隐藏元素
- 渲染树是不包含head和隐藏元素
